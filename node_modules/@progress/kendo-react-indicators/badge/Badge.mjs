/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import l from "prop-types";
import { validatePackage as v, useDir as y, classNames as O, kendoThemeMaps as C } from "@progress/kendo-react-common";
import { packageMetadata as B } from "../package-metadata.mjs";
const m = t.forwardRef((e, g) => {
  v(B);
  const {
    children: h,
    className: c,
    style: b
  } = e, i = t.useRef(null), k = t.useCallback(
    () => {
      i.current && i.current.focus();
    },
    []
  );
  t.useImperativeHandle(g, () => ({
    element: i.current,
    focus: k
  }));
  const M = y(i, e.dir), a = t.useMemo(
    () => e.size === null ? null : e.size || n.size,
    [e.size]
  ), r = t.useMemo(
    () => e.fillMode === null || e.fill === null ? null : e.fill || e.fillMode || n.fillMode,
    [e.fillMode, e.fill]
  ), u = t.useMemo(
    () => e.themeColor || n.themeColor,
    [e.themeColor]
  ), d = t.useMemo(
    () => {
      if (e.rounded !== void 0)
        return e.rounded || "medium";
      if (e.shape !== void 0)
        switch (e.shape) {
          case "rounded":
            return "md";
          case "rectangle":
            return null;
          default:
            return "full";
        }
      return "medium";
    },
    [e.rounded, e.shape]
  ), {
    cutoutBorder: f = n.cutoutBorder,
    position: s = n.position,
    align: o = n.align
  } = e, z = t.useMemo(
    () => O(
      "k-badge",
      {
        "k-badge-sm": a === "small",
        "k-badge-md": a === "medium",
        "k-badge-lg": a === "large",
        [`k-badge-${r}`]: r,
        [`k-badge-${r}-${u}`]: !!(r && u),
        [`k-rounded-${C.roundedMap[d] || d}`]: d,
        "k-badge-border-cutout": f,
        [`k-badge-${s}`]: s,
        "k-top-start": o.vertical === "top" && o.horizontal === "start",
        "k-top-end": o.vertical === "top" && o.horizontal === "end",
        "k-bottom-start": o.vertical === "bottom" && o.horizontal === "start",
        "k-bottom-end": o.vertical === "bottom" && o.horizontal === "end"
      },
      c
    ),
    [
      a,
      r,
      u,
      d,
      f,
      o,
      s,
      c
    ]
  );
  return /* @__PURE__ */ t.createElement("span", { className: z, style: b, dir: M }, h);
});
m.propTypes = {
  className: l.string,
  dir: l.string,
  style: l.object,
  align: l.shape({
    vertical: l.oneOf(["top", "bottom"]),
    horizontal: l.oneOf(["start", "end"])
  }),
  size: l.oneOf([null, "small", "medium", "large"]),
  fillMode: l.oneOf([null, "solid", "outline"]),
  fill: l.oneOf([null, "solid", "outline"]),
  themeColor: l.oneOf([
    null,
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "warning",
    "error",
    "dark",
    "light",
    "inverse",
    "inherit"
  ]),
  shape: l.oneOf(["circle", "rectangle", "rounded", "dot", "pill"]),
  rounded: l.oneOf([null, "small", "medium", "large", "full"]),
  position: l.oneOf(["edge", "outside", "inside"]),
  cutoutBorder: l.bool
};
const n = {
  size: "medium",
  fillMode: "solid",
  themeColor: "primary",
  position: "edge",
  align: { vertical: "top", horizontal: "end" },
  cutoutBorder: !1
};
m.defaultProps = n;
m.displayName = "KendoBadge";
export {
  m as Badge
};
